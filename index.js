// userbot_with_debug.js
require("dotenv").config();
const { TelegramClient } = require("telegram");
const { StringSession } = require("telegram/sessions");
const { NewMessage } = require("telegram/events");
const input = require("input");

// parseInt(, 10);
// process.env.API_ID
const apiId = parseInt(process.env.API_ID, 10)
const apiHash = process.env.API_HASH;
let stringSession = process.env.STRING_SESSION || "";

console.log("STRING_SESSION –∑–∞–≥—Ä—É–∂–µ–Ω?", process.env.STRING_SESSION?.slice(0, 15), "–¥–ª–∏–Ω–∞:", process.env.STRING_SESSION?.length);


const targetGroupName = process.env.TARGET_GROUP_NAME; // –ø—Ä–∏–º–µ—Ä: ORDERS
const logGroupTitle = process.env.LOG_GROUP_TITLE;     // –ø—Ä–∏–º–µ—Ä: Reklama (–∏–ª–∏ –º–æ–∂–Ω–æ –¥–∞—Ç—å ID)
const keywords = process.env.KEYWORDS ? process.env.KEYWORDS.split(",") : [];



// TARGET_FOLDER_ID –∏–∑ .env (–µ—Å–ª–∏ –ø—É—Å—Ç ‚Äî –±—É–¥–µ—Ç null)
const rawFolder = process.env.TARGET_FOLDER_ID;
const targetFolderId = rawFolder ? parseInt(rawFolder, 10) : null;
console.log('API_ID:', apiId);
console.log('API_HASH exists:', !!apiHash);

if (!apiId || !apiHash) {
    console.error('API_ID:', process.env.API_ID);
    console.error('API_HASH:', process.env.API_HASH ? 'exists' : 'missing');
    throw new Error('API credentials are missing');
}


const client = new TelegramClient(new StringSession(stringSession), apiId, apiHash, { connectionRetries: 5 });

let resolvedLogPeer = null;     // id –≥—Ä—É–ø–ø—ã –ª–æ–≥–æ–≤ (–µ—Å–ª–∏ –Ω–∞—à–ª–∏)
let resolvedTargetPeer = null;  // id targetGroupName (–¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤)

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// –ü–æ–ø—ã—Ç–∞—Ç—å—Å—è —Ä–µ–∑–æ–ª–≤–∏—Ç—å –¥–∏–∞–ª–æ–≥ –ø–æ title/username/—á–∏—Å–ª–æ–≤–æ–º—É id
async function resolveDialogPeer(identifier) {
    if (!identifier) return null;
    // –µ—Å–ª–∏ —ç—Ç–æ —á–∏—Å–ª–æ–≤–æ–π id –≤ .env ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ –µ—Å—Ç—å
    if (/^-?\d+$/.test(String(identifier).trim())) {
        return Number(identifier);
    }
    const dialogs = await client.getDialogs();
    const found = dialogs.find(d => d.title === identifier || d.username === identifier || String(d.id) === identifier);
    return found ? found.id : null;
}

// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ ‚Äî –ø—Ä–∏–Ω–∏–º–∞–µ—Ç title/username/ID
async function sendToGroup(groupIdentifier, text) {
    try {
        let peer = groupIdentifier;

        // –µ—Å–ª–∏ —ç—Ç–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ª–æ–≥-—Ç–∞–π—Ç–ª –∏ –º—ã —É–∂–µ —Ä–µ–∑–æ–ª–≤–∏–ª–∏ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º id
        if (groupIdentifier === logGroupTitle && resolvedLogPeer) peer = resolvedLogPeer;
        else if (groupIdentifier === targetGroupName && resolvedTargetPeer) peer = resolvedTargetPeer;
        else if (typeof groupIdentifier === "string" && /^-?\d+$/.test(groupIdentifier.trim())) {
            peer = Number(groupIdentifier);
        } else if (typeof groupIdentifier === "string") {
            // –ø–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –ø–æ title/username –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å
            const dialogs = await client.getDialogs();
            const found = dialogs.find(d => d.title === groupIdentifier || d.username === groupIdentifier);
            if (found) peer = found.id;
            // –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî –æ—Å—Ç–∞–≤–∏–º —Å—Ç—Ä–æ–∫—É (client.sendMessage –ø–æ–ø—ã—Ç–∞–µ—Ç—Å—è —Ä–µ–∑–æ–ª–≤–∏—Ç—å username)
        }

        await client.sendMessage(peer, { message: text });
    } catch (err) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤ "${groupIdentifier}":`, err);
    }
}

// ===== –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ –ò–∑–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ –ø–∞–ø–∫–µ rozyob —Ä–∞–∑ –≤ 3 –º–∏–Ω—É—Ç—ã =====
async function broadcastFromMe() {
    let currentIndex = 0;

    while (true) {
        try {
            const dialogs = await client.getDialogs();
            const groups = dialogs.filter(d => (d.isGroup || d.isChannel) && d.folderId === targetFolderId);

            if (!groups.length) {
                console.log("‚ö† –ù–µ—Ç –≥—Ä—É–ø–ø –≤ –ø–∞–ø–∫–µ TARGET_FOLDER_ID");
                await sleep(60000);
                continue;
            }

            const lastMessage = (await client.getMessages("me", { limit: 1 }))[0];
            if (!lastMessage) {
                console.log("‚ö† –ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –ò–∑–±—Ä–∞–Ω–Ω–æ–º");
                await sleep(60000);
                continue;
            }

            const group = groups[currentIndex % groups.length];

            try {
                // –ü–µ—Ä–µ—Å—ã–ª–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞–ø—Ä—è–º—É—é, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å –ø—Ä–µ–º–∏—É–º-—ç–º–æ–¥–∑–∏, —Å—Ç–∏–∫–µ—Ä—ã –∏ –º–µ–¥–∏–∞
                const forwardedArr = await client.forwardMessages(group.entity, {
                    messages: [lastMessage.id],
                    fromPeer: "me"
                });

                const forwarded = Array.isArray(forwardedArr) ? forwardedArr[0] : forwardedArr;
                const msgIdToDelete = forwarded?.id;

                // –õ–æ–≥–∏—Ä—É–µ–º
                const logText = `‚úÖ –ü–µ—Ä–µ—Å–ª–∞–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ "${group.title}"\nID —Å–æ–æ–±—â–µ–Ω–∏—è: ${lastMessage.id}`;
                if (resolvedLogPeer) await sendToGroup(resolvedLogPeer, logText);
                else await sendToGroup(logGroupTitle, logText);

                // –£–¥–∞–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 1 –º–∏–Ω—É—Ç—É
                if (msgIdToDelete) {
                    setTimeout(async () => {
                        try {
                            await client.deleteMessages(group.id, [msgIdToDelete]);
                            console.log(`üóë –°–æ–æ–±—â–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ –∏–∑ "${group.title}"`);
                        } catch (err) {
                            console.error(`–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ "${group.title}":`, err);
                        }
                    }, 60 * 1000);
                }

            } catch (err) {
                console.error(`–û—à–∏–±–∫–∞ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –≤ "${group.title}":`, err);
                // fallback ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç, –µ—Å–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞
                if (lastMessage.message) {
                    await client.sendMessage(group.id, { message: lastMessage.message });
                }
            }

            currentIndex++;
            console.log("‚è± –ñ–¥—É 3 –º–∏–Ω—É—Ç—ã –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –≥—Ä—É–ø–ø—ã...");
            await sleep(3 * 60 * 1000);

        } catch (err) {
            console.error("–û—à–∏–±–∫–∞ –≤ broadcastFromMe:", err);
            await sleep(20000);
        }
    }
}





const recentMessages = new Map(); // –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –¥—É–±–ª–µ–π

client.addEventHandler(async (event) => {
    try {
        const messageText = event.message.message?.toLowerCase();
        if (!messageText || messageText.length > 15) return;

        if (keywords.some(k => messageText.includes(k))) {
            let chat, sender;
            try { chat = await event.message.getChat(); } catch { }
            try { sender = await event.message.getSender(); } catch { }

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–º—è/username –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
            let senderName = "[UNKNOWN]";
            let senderId = sender?.id;
            if (sender?.username) {
                senderName = `@${sender.username}`;
            } else {
                try {
                    const fullSender = await client.getEntity(event.message.senderId);
                    if (fullSender?.username) {
                        senderName = `@${fullSender.username}`;
                    } else if (fullSender?.firstName) {
                        senderName = fullSender.firstName + (fullSender.lastName ? " " + fullSender.lastName : "");
                    } else {
                        senderName = `[ID:${fullSender.id}]`;
                    }
                    senderId = fullSender?.id;
                } catch {
                    senderName = sender?.id ? `[ID:${sender.id}]` : "[UNKNOWN]";
                }
            }

            // ===== –ê–ù–¢–ò–°–ü–ê–ú-–§–ò–õ–¨–¢–† =====
            const uniqueKey = `${senderId}_${messageText}`; // —É–Ω–∏–∫–∞–ª—å–Ω–∞—è –∫–æ–º–±–∏–Ω–∞—Ü–∏—è (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å + —Ç–µ–∫—Å—Ç)
            if (recentMessages.has(uniqueKey)) {
                // –£–∂–µ –±—ã–ª–æ —Ç–∞–∫–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 3 –º–∏–Ω—É—Ç—ã ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
                return;
            }

            // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –∏ —Å—Ç–∞–≤–∏–º —Ç–∞–π–º–µ—Ä –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ
            recentMessages.set(uniqueKey, true);
            setTimeout(() => recentMessages.delete(uniqueKey), 3 * 60 * 1000); // —É–¥–∞–ª—è–µ–º —á–µ—Ä–µ–∑ 3 –º–∏–Ω—É—Ç—ã

            // ===== –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞s =====
            const groupName = chat?.title || `[ID:${chat?.id}]`;
            const msgLink = chat?.username
                ? `https://t.me/${chat.username}/${event.message.id}`
                : `[ID:${chat?.id}, msgId:${event.message.id}]`;
            const groupLink = chat?.username ? `https://t.me/${chat.username}` : `[ID:${chat?.id}]`;

            const text = `[‚ö°] ${senderName} | ${groupName}\n"${event.message.message}"\nüîó ${msgLink}\nüåê ${groupLink}`;

            // –∏—Å–ø–æ–ª—å–∑—É–µ–º resolvedTargetPeer –µ—Å–ª–∏ –µ—Å—Ç—å
            if (resolvedTargetPeer) {
                await sendToGroup(resolvedTargetPeer, text);
            } else {
                await sendToGroup(targetGroupName, text);
            }
        }
    } catch (err) {
        console.error("–û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤:", err);
    }
}, new NewMessage({ incoming: true }));



// ===== –ó–∞–ø—É—Å–∫ –∫–ª–∏–µ–Ω—Ç–∞ –∏ —Ä–µ–∑–æ–ª–≤ –≥—Ä—É–ø–ø =====
async function startClient() {
    if (!stringSession || stringSession.trim() === "") {
        await client.start({
            phoneNumber: async () => await input.text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞: "),
            password: async () => await input.text("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å (2FA): "),
            phoneCode: async () => await input.text("–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∏–∑ Telegram: "),
            onError: (err) => console.log(err),
        });
        stringSession = client.session.save();
        console.log("‚úÖ UserBot –∑–∞–ø—É—â–µ–Ω! –°–∫–æ–ø–∏—Ä—É–π STRING_SESSION –≤ .env");
        console.log(stringSession);
    } else {
        await client.connect();
        console.log("‚úÖ UserBot –ø–æ–¥–∫–ª—é—á–µ–Ω —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Å–µ—Å—Å–∏–µ–π!");
    }

    // –ü–æ–ø—Ä–æ–±—É–µ–º —Ä–µ–∑–æ–ª–≤–∏—Ç—å –ª–æ–≥-–≥—Ä—É–ø–ø—É –∏ —Ü–µ–ª—å –¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
    if (logGroupTitle) {
        resolvedLogPeer = await resolveDialogPeer(logGroupTitle);
        if (resolvedLogPeer) console.log("üîé LOG_GROUP_TITLE —Ä–µ–∑–æ–ª–≤–ª–µ–Ω –≤ id:", resolvedLogPeer);
        else console.warn("‚ö† LOG_GROUP_TITLE –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ title/username. –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å ID –≤ LOG_GROUP_TITLE –≤ .env");
    }
    if (targetGroupName) {
        resolvedTargetPeer = await resolveDialogPeer(targetGroupName);
        if (resolvedTargetPeer) console.log("üîé TARGET_GROUP_NAME —Ä–µ–∑–æ–ª–≤–ª–µ–Ω –≤ id:", resolvedTargetPeer);
        else console.warn("‚ö† TARGET_GROUP_NAME –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ title/username. –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å ID –≤ TARGET_GROUP_NAME –≤ .env");
    }
}

// ===== –ì–ª–∞–≤–Ω—ã–π –∑–∞–ø—É—Å–∫ =====
(async () => {
    await startClient();
    broadcastFromMe();
})();


